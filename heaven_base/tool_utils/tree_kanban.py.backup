from typing import List, Optional
from .github_kanban import KanbanBoard, Issue, construct_kanban_from_labels

def parse_tree_priority(priority_str: str) -> List[int]:
    """Parse tree notation priority into list of integers for sorting"""
    if priority_str == 'high':
        return [1]
    elif priority_str == 'medium':
        return [2] 
    elif priority_str == 'low':
        return [3]
    
    try:
        return [int(part) for part in priority_str.split('.')]
    except ValueError:
        return [999]

def get_issue_priority(issue: Issue) -> List[int]:
    """Get priority from issue labels"""
    for label in issue.labels:
        if label.startswith('priority-'):
            priority_part = label[9:]
            return parse_tree_priority(priority_part)
    return [999]

def sort_issues_by_tree_priority(issues: List[Issue]) -> List[Issue]:
    """Sort issues by tree priority"""
    return sorted(issues, key=get_issue_priority)

def construct_tree_kanban(repo: str = 'sancovp/heaven-base') -> KanbanBoard:
    """Construct kanban board with tree priority sorting"""
    board = construct_kanban_from_labels(repo)
    
    # Sort all lanes by tree priority
    board.backlog = sort_issues_by_tree_priority(board.backlog)
    board.plan = sort_issues_by_tree_priority(board.plan)
    board.build = sort_issues_by_tree_priority(board.build)
    board.measure = sort_issues_by_tree_priority(board.measure)
    board.learn = sort_issues_by_tree_priority(board.learn)
    board.blocked = sort_issues_by_tree_priority(board.blocked)
    board.archived = sort_issues_by_tree_priority(board.archived)
    
    return board

def get_issue_priority_string(issue: Issue) -> Optional[str]:
    """Get priority string from issue labels"""
    for label in issue.labels:
        if label.startswith('priority-'):
            return label[9:]
    return None

def demo_tree_kanban():
    """Demo the tree kanban system"""
    board = construct_tree_kanban()
    print("ðŸŒ³ TREE KANBAN BOARD")
    print("=" * 50)
    print(f"ðŸ“‹ PLAN ({len(board.plan)} issues)")
    for issue in board.plan:
        priority = get_issue_priority_string(issue)
        print(f"   #{issue.number}: {issue.title[:50]} (priority: {priority or 'none'})")


def create_priority_label_if_needed(repo: str, priority: str) -> bool:
    """Create priority label if it doesn't exist"""
    import subprocess
    import json
    
    label_name = f'priority-{priority}'
    
    # Check if label exists
    try:
        cmd = f'gh api repos/{repo}/labels/{label_name}'
        subprocess.run(cmd, shell=True, check=True, capture_output=True)
        return True  # Label exists
    except subprocess.CalledProcessError:
        pass  # Label doesn't exist, create it
    
    # Create label with tree-aware color coding
    depth = priority.count('.')
    colors = ['1f77b4', '2ca02c', 'd62728', 'ff7f0e', '9467bd', '8c564b', 'e377c2', '7f7f7f', 'bcbd22']
    color = colors[depth % len(colors)]
    
    try:
        cmd = f'gh api repos/{repo}/labels -f name="{label_name}" -f color="{color}" -f description="Tree priority {priority}"'
        subprocess.run(cmd, shell=True, check=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Failed to create label {label_name}: {e}")
        return False

def set_issue_tree_priority(repo: str, issue_number: int, priority: str) -> bool:
    """Set tree priority on issue, creating label if needed"""
    import subprocess
    
    # Create label if needed
    if not create_priority_label_if_needed(repo, priority):
        return False
    
    # Remove existing priority labels
    try:
        cmd = f'gh issue view {issue_number} --repo {repo} --json labels'
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        labels = json.loads(result.stdout)['labels']
        
        for label in labels:
            if label['name'].startswith('priority-'):
                subprocess.run(f'gh issue edit {issue_number} --repo {repo} --remove-label "{label["name"]}"', shell=True)
    except:
        pass
    
    # Add new priority label
    try:
        cmd = f'gh issue edit {issue_number} --repo {repo} --add-label "priority-{priority}"'
        subprocess.run(cmd, shell=True, check=True)
        return True
    except subprocess.CalledProcessError:
        return False


def get_parent_priority(priority: str) -> str:
    """Get parent priority from tree notation (1.2.3 -> 1.2)"""
    parts = priority.split('.')
    return '.'.join(parts[:-1]) if len(parts) > 1 else None

def find_issue_by_priority(repo: str, target_priority: str):
    """Find issue with specific priority"""
    import subprocess
    import json
    
    try:
        # Search for issues with the priority label
        cmd = f'gh issue list --repo {repo} --label "priority-{target_priority}" --json number,labels --limit 1'
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        issues = json.loads(result.stdout)
        return issues[0]['number'] if issues else None
    except:
        return None

def get_issue_status(repo: str, issue_number: int) -> str:
    """Get current status of an issue"""
    import subprocess
    import json
    
    try:
        cmd = f'gh issue view {issue_number} --repo {repo} --json labels'
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        labels = json.loads(result.stdout)['labels']
        
        for label in labels:
            if label['name'].startswith('status-'):
                return label['name'][7:]  # Remove 'status-' prefix
        return 'backlog'  # Default status
    except:
        return 'backlog'

def set_issue_status(repo: str, issue_number: int, status: str) -> bool:
    """Set status label on issue"""
    import subprocess
    import json
    
    try:
        # Remove existing status labels
        cmd = f'gh issue view {issue_number} --repo {repo} --json labels'
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        labels = json.loads(result.stdout)['labels']
        
        for label in labels:
            if label['name'].startswith('status-'):
                subprocess.run(f'gh issue edit {issue_number} --repo {repo} --remove-label "{label["name"]}"', shell=True)
        
        # Add new status label
        cmd = f'gh issue edit {issue_number} --repo {repo} --add-label "status-{status}"'
        subprocess.run(cmd, shell=True, check=True)
        return True
    except:
        return False

def set_issue_tree_priority_with_inheritance(repo: str, issue_number: int, priority: str) -> bool:
    """Set tree priority with automatic status inheritance from parent"""
    
    # First set the priority label
    if not set_issue_tree_priority(repo, issue_number, priority):
        return False
    
    # Check if this is a subtask (has parent)
    parent_priority = get_parent_priority(priority)
    if parent_priority:
        # Find parent issue
        parent_issue = find_issue_by_priority(repo, parent_priority)
        if parent_issue:
            # Inherit parent's status
            parent_status = get_issue_status(repo, parent_issue)
            set_issue_status(repo, issue_number, parent_status)
            print(f"Issue #{issue_number} inherited status '{parent_status}' from parent #{parent_issue}")
    
    return True

def sync_tree_statuses(repo: str, root_priority: str) -> None:
    """Sync all issues in a tree to have consistent statuses"""
    import subprocess
    import json
    
    # Get all issues with priorities starting with root_priority
    try:
        cmd = f'gh issue list --repo {repo} --json number,labels --limit 100'
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
        all_issues = json.loads(result.stdout)
        
        tree_issues = []
        for issue in all_issues:
            for label in issue['labels']:
                if label['name'].startswith(f'priority-{root_priority}'):
                    priority = label['name'][9:]  # Remove 'priority-' prefix
                    tree_issues.append((issue['number'], priority))
                    break
        
        # Sort by tree depth (parents first)
        tree_issues.sort(key=lambda x: x[1].count('.'))
        
        # Apply status inheritance
        for issue_num, priority in tree_issues:
            parent_priority = get_parent_priority(priority)
            if parent_priority:
                parent_issue = find_issue_by_priority(repo, parent_priority)
                if parent_issue:
                    parent_status = get_issue_status(repo, parent_issue)
                    set_issue_status(repo, issue_num, parent_status)
                    print(f"Synced #{issue_num} (priority {priority}) to status '{parent_status}'")
    
    except Exception as e:
        print(f"Error syncing tree statuses: {e}")

# Priority Programming Language Functions
# =====================================

def prioritize_above(issue_id: str, target_issue_id: str, repo: str) -> str:
    """Move issue to priority above target issue using priority programming language.
    
    Args:
        issue_id: Issue number to move
        target_issue_id: Issue number to move above  
        repo: Repository name (owner/repo)
        
    Returns:
        New priority string assigned
    """
    import requests
    import os
    
    # Get target issue priority
    target_priority = get_issue_priority_string(repo, target_issue_id)
    if not target_priority:
        raise ValueError(f"Could not get priority for issue #{target_issue_id}")
    
    # Apply "above" rule: add "0" to end
    new_priority = target_priority + "0"
    
    # Set new priority on issue
    set_issue_tree_priority(repo, issue_id, new_priority)
    
    print(f"Moved issue #{issue_id} above #{target_issue_id}: {target_priority} â†’ {new_priority}")
    return new_priority

def prioritize_between(issue_id: str, higher_issue_id: str, lower_issue_id: str, repo: str) -> str:
    """Move issue between two other issues using priority programming language.
    
    Args:
        issue_id: Issue number to move
        higher_issue_id: Issue with higher priority (lower number)
        lower_issue_id: Issue with lower priority (higher number)
        repo: Repository name (owner/repo)
        
    Returns:
        New priority string assigned
    """
    import requests
    import os
    
    # Get higher issue priority
    higher_priority = get_issue_priority_string(repo, higher_issue_id)
    if not higher_priority:
        raise ValueError(f"Could not get priority for issue #{higher_issue_id}")
    
    # Find next available digit after higher priority
    base_priority = higher_priority
    digit = 1
    
    while True:
        candidate_priority = base_priority + str(digit)
        # Check if this priority is already taken
        existing_issue = find_issue_by_priority(repo, candidate_priority)
        if not existing_issue:
            new_priority = candidate_priority
            break
        digit += 1
        if digit > 9:
            # If we run out of single digits, add another zero and start over
            base_priority = base_priority + "0"
            digit = 1
    
    # Set new priority on issue
    set_issue_tree_priority(repo, issue_id, new_priority)
    
    print(f"Moved issue #{issue_id} between #{higher_issue_id} and #{lower_issue_id}: {new_priority}")
    return new_priority

def prioritize_as_subtask(issue_id: str, parent_issue_id: str, repo: str, subtask_index: Optional[int] = None) -> str:
    """Make issue a subtask of parent issue using priority programming language.
    
    Args:
        issue_id: Issue number to move
        parent_issue_id: Parent issue number
        repo: Repository name (owner/repo)
        subtask_index: Specific subtask number (auto-assigned if None)
        
    Returns:
        New priority string assigned
    """
    import requests
    import os
    
    # Get parent issue priority
    parent_priority = get_issue_priority_string(repo, parent_issue_id)
    if not parent_priority:
        raise ValueError(f"Could not get priority for issue #{parent_issue_id}")
    
    # Find next available subtask index if not specified
    if subtask_index is None:
        subtask_index = 1
        while True:
            candidate_priority = f"{parent_priority}.{subtask_index}"
            existing_issue = find_issue_by_priority(repo, candidate_priority)
            if not existing_issue:
                break
            subtask_index += 1
    
    new_priority = f"{parent_priority}.{subtask_index}"
    
    # Set new priority on issue
    set_issue_tree_priority(repo, issue_id, new_priority)
    
    print(f"Made issue #{issue_id} subtask of #{parent_issue_id}: {new_priority}")
    return new_priority

def get_issue_priority_string(repo: str, issue_id: str) -> Optional[str]:
    """Get the priority string for an issue.
    
    Args:
        repo: Repository name (owner/repo) 
        issue_id: Issue number
        
    Returns:
        Priority string (e.g. "0.1.2") or None if no priority found
    """
    import requests
    import os
    
    headers = {
        'Authorization': f'token {os.environ["GITHUB_TOKEN"]}',
        'Accept': 'application/vnd.github.v3+json'
    }
    
    try:
        response = requests.get(f'https://api.github.com/repos/{repo}/issues/{issue_id}', headers=headers)
        response.raise_for_status()
        issue_data = response.json()
        
        # Find priority label
        for label in issue_data.get('labels', []):
            if label['name'].startswith('priority-'):
                return label['name'][9:]  # Remove 'priority-' prefix
        
        return None
    except Exception as e:
        print(f"Error getting priority for issue #{issue_id}: {e}")
        return None
